# 层次分析法



# 层次分析法
## 一、基本步骤
1、建立层次结构模型。在深入分析实际问题的基础上，将有关的各个因素按照不同属性自上而下地分解成若干层次，同一层的诸因素从属于上一层的因素或对上层因素有影响，同时又支配下一层的因素或受到下层因素的作用。最上层为目标层，通常只有1个因素，最下层通常为方案或对象层，中间可以有一个或几个层次，通常为准则或指标层。当准则过多时(譬如多于9个)应进一步分解出子准则层。

2、构造成对比较阵。从层次结构模型的第2层开始，对于从属于(或影响)上一层每个因素的同一层诸因素，用成对比较法和1—9比较尺度构造成对比较阵，直到最下层。

3、计算权向量并做一致性检验。对于每一个成对比较阵计算最大特征根及对应特征向量，利用一致性指标、随机一致性指标和一致性比率做一致性检验。若检验通过，特征向量(归一化后)即为权向量：若不通过，需重新构造成对比较阵。

4、计算组合权向量并做组合一致性检验。计算最下层对目标的组合权向量，并根据公式做组合一致性检验，若检验通过，则可按照组合权向量表示的结果进行决策，否则需要重新考虑模型或重新构造那些一致性比率较大的成对比较阵。
## 二、建立模型

## 三、构建比较矩阵
比较第i个元素与第j个元素相对上一层某个因素的重要性时，使用数量化的相对权重a i j来描述。设共有n个元素参与比较，则$A=(a_{ij})\_{n\times n}$称为成对比较矩阵。

　　成对比较矩阵中a i j的取值可参考Satty的提议，按下述标度进行赋值。a i j在1-9及其倒数中间取值。

- a i j = 1，元素i与元素j对上一层次因素的重要性相同；
- a i j = 3，元素i比元素j略重要；
- a i j = 5，元素i比元素j重要；
- a i j = 7，元素i比元素j重要得多；
- a i j = 9，元素i比元素j的极其重要；
- a i j = 2 n，n=1,2,3,4，元素i与j的重要性介于$a_{ij} = 2 n − 1$与 $a_{ij} = 2 n + 1$之间；
- $a_{ij}=\frac{1}{n}$，n=1,2,...,9，当且仅当a j i = n。

成对比较矩阵的特点：$a_{ij}>0,a_{ij}=1,a_{ij}=\frac{1}{a_{ji}}$。（备注：当i=j时候，a i j = 1）

## 四、一致性检验
从理论上分析得到：如果A是完全一致的成对比较矩阵，应该有

$$
a_{ij}a_{jk} = a_{ik}, 1<i,j,k\leq n
$$

但实际上在构造成对比较矩阵时要求满足上述众多等式是不可能的。因此退而要求成对比较矩阵有一定的一致性，即可以允许成对比较矩阵存在一定程度的不一致性。

由分析可知，对完全一致的成对比较矩阵，其绝对值最大的特征值等于该矩阵的维数。对成对比较矩阵的一致性要求，转化为要求： 的绝对值最大的特征值和该矩阵的维数相差不大。

检验成对比较矩阵A一致性的步骤如下：
计算衡量一个成对比较矩阵A （n>1 阶方阵）不一致程度的指标CI：

$$
CI = \frac{\lambda_{max}(A)-n}{n-1}
$$

判断方法如下： 当CR<0.1时，判定成对比较阵A 具有满意的一致性，或其不一致程度是可以接受的；否则就调整成对比较矩阵A，直到达到满意的一致性为止。
## 五、求权重
## 六、计算结果

## 附：求权重的python代码
```python
# 层次分析法
import numpy as np

RI_dict = {1: 0, 2: 0, 3: 0.58, 4: 0.90, 5: 1.12, 6: 1.24, 7: 1.32, 8: 1.41, 9: 1.45}

A = [[1, 1/2, 4, 3, 3],
 [2, 1, 7, 5, 5],
 [1/4, 1/7, 1, 1/2, 1/3],
 [1/3, 1/5, 2, 1, 1],
 [1/3, 1/5, 3, 1, 1]]
n = len(A)
# 算数平均法求权重
Sum_A = np.sum(A, axis=0, keepdims=True)
print("算数平均值法：")
print(np.sum(A / Sum_A, axis=1) / n)
print("")

# 几何平均法求权重
mul = np.prod(A, axis=1)
temp = mul ** (1/n)
print(temp / np.sum(temp))

# 特征值法求权重
d,v = np.linalg.eig(A) # d为特征值，v为特征向量
Max_eig = np.max(d)
c = np.where(d == Max_eig)[0]
print("特征值法：")
res = v[:, c] / sum(v[:, c])
print(np.squeeze(res))


CI = (Max_eig - n) / (n - 1)
RI = RI_dict[n]
CR = CI / RI
if CR < 0.1:
    print(f"CR的值为{CR}，一致性可以接受")
else:
    print(f"CR的值为{CR}，一致性不可以接受")
```
