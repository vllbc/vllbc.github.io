# 信号量

## 信号量
之前说的都无法实现让权等待，会导致一直在忙等，因此引入了信号量机制。

信号量可以理解为系统中某种资源的数量，通过一对原语来对信号量进行操作.
wait(S) 原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal（译为：信号）,括号里的信号量S其实就是函数调用时传入的一个参数。wait相当于等待某资源，有的话就消耗，没有就阻塞进程。signal是释放某个资源，对于记录型信号量，也会唤醒某进程，继续执行阻塞后面的任务。
## 整型信号量(二进制信号量)
![](image/Pasted%20image%2020230313112743.png)

这种信号量只能是非负的，当等于0的时候就要阻塞。直到有进程释放资源。这种的信号量也无法实现让权等待，本质也是个互斥锁。
## 记录型信号量(计数信号量)
整型信号量的缺陷是存在“忙等”问题
![](image/Pasted%20image%2020230313113000.png)
![](image/Pasted%20image%2020230313105417.png)

## 信号量的作用

### 实现互斥
-   分析并发进程的关键活动，划定临界区(如:对临界资源打印机的访问就应放在临界区)
-   设置互斥信号量mutex，初值为1.
-   在临界区之前执行P(mutex)
-   在临界区之后执行V(mutex)

对不同的临界资源需要设置不同的互斥信号量。
![](image/Pasted%20image%2020230313113643.png)

### 实现进程同步
-   分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作( 或两句代码)
-   设置同步信号量S,初始为0
-   在“前操作”之后执行V(S)
-   在“后操作”之前执行P(S)
![](image/Pasted%20image%2020230313113707.png)

![](image/Pasted%20image%2020230313113738.png)

初始S=0，如果执行P2，则S=-1，会一直阻塞，只有当代码2执行之后释放了S，S=0，此时P2继续执行代码4，以此实现了进程同步。
这种其实就是相当于发信号，当代码2执行完了之后，发信号告诉P2可以继续往下执行代码4了。P就是wait就是等待信号。

### 实现前驱关系
进程P1中有句代码S1，P2中有句代码S2…P6中有句代码S6。这些代码要求按如下前驱图所  
示的顺序来执行:
其实每一对前驱关系都是一个进程同步问题(需要保证一前一后的操作)  
因此，

-   要为每一对前驱关系各设置一个同步变量
-   在“前操作”之后对相应的同步变量执行V操作
-   在“后操作”之前对相应的同步变量执行P操作
![](image/Pasted%20image%2020230313114235.png)


## 生产者-消费者问题
定义三个信号量，它正值和负值代表的含义是不一样的，正值代表可用的资源数，负值代表有多少进程在等待资源的释放。一个代表空闲的缓冲区，当空闲的缓冲区为0即缓冲区满的时候，再次生产就会阻塞生产者进程。一个代表生产者已经生成的数量即占用的缓冲区，当占用的缓冲区为0时代表缓冲区为空，此时再消费就会阻塞消费者进程。还有一个是互斥信号量，防止一个进程访问的时候另一个进程访问。

代码实现：
![](image/Pasted%20image%2020230313105417.png)

对于生产者消费者问题，伪代码大致如下：
![](image/Pasted%20image%2020230313105321.png)

![](image/Pasted%20image%2020230313120936.png)

一般的过程不再讲解，当空闲缓冲区的数量为0时，这时再进行生产则会阻塞当前进程，再继续生产会继续阻塞，假设这样下去e的值是-m，当调用signal释放资源时，则会唤醒一个阻塞进程，当进程被唤醒了，再经过调度继续运行下面的代码，会执行signal(n)，即会增加占用的缓冲区数，这样一个来回，n还是原来的n，假设一直执行消费者程序，当一共执行了m次以后，此时e变成了0，而n还是原来的n，再执行下去e就变回了正数，生产者程序再执行就不会阻塞。mutex也是一样，记住一点就可以了，就是阻塞进程被唤醒后是从被阻塞的地方继续往下执行。这与进程切换联系了起来。

这里wait(P)相当于申请系统资源，signal(V)相当于释放系统资源。
