<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="vllbc">
    <link rel="canonical" href="https://vllbc.github.io/Cookbook/chapter1/">
    <link rel="shortcut icon" href="../../1.ico">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>第一章 - Vllbc's home</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u73b0\u5728\u6709\u4e00\u4e2a\u5305\u542b N \u4e2a\u5143\u7d20\u7684\u5143\u7ec4\u6216\u8005\u662f\u5e8f\u5217\uff0c\u600e\u6837\u5c06\u5b83\u91cc\u9762\u7684\u503c\u89e3\u538b\u540e\u540c\u65f6\u8d4b\u503c\u7ed9 N \u4e2a\u53d8\u91cf\uff1f", url: "#_top", children: [
          ]},
          {title: "\u5982\u679c\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u7684\u5143\u7d20\u4e2a\u6570\u8d85\u8fc7\u53d8\u91cf\u4e2a\u6570\u65f6\uff0c\u4f1a\u629b\u51fa\u4e00\u4e2a ValueError \u3002 \u90a3\u4e48\u600e\u6837\u624d\u80fd\u4ece\u8fd9\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e2d\u89e3\u538b\u51fa N \u4e2a\u5143\u7d20\u51fa\u6765\uff1f", url: "#valueerror-n", children: [
          ]},
          {title: "\u5728\u8fed\u4ee3\u64cd\u4f5c\u6216\u8005\u5176\u4ed6\u64cd\u4f5c\u7684\u65f6\u5019\uff0c\u600e\u6837\u53ea\u4fdd\u7559\u6700\u540e\u6709\u9650\u51e0\u4e2a\u5143\u7d20\u7684\u5386\u53f2\u8bb0\u5f55\uff1f", url: "#_1", children: [
          ]},
          {title: "\u600e\u6837\u4ece\u4e00\u4e2a\u96c6\u5408\u4e2d\u83b7\u5f97\u6700\u5927\u6216\u8005\u6700\u5c0f\u7684 N \u4e2a\u5143\u7d20\u5217\u8868\uff1f", url: "#n", children: [
          ]},
          {title: "\u600e\u6837\u5b9e\u73b0\u4e00\u4e2a\u6309\u4f18\u5148\u7ea7\u6392\u5e8f\u7684\u961f\u5217\uff1f \u5e76\u4e14\u5728\u8fd9\u4e2a\u961f\u5217\u4e0a\u9762\u6bcf\u6b21 pop \u64cd\u4f5c\u603b\u662f\u8fd4\u56de\u4f18\u5148\u7ea7\u6700\u9ad8\u7684\u90a3\u4e2a\u5143\u7d20", url: "#pop", children: [
          ]},
          {title: "\u600e\u6837\u5b9e\u73b0\u4e00\u4e2a\u952e\u5bf9\u5e94\u591a\u4e2a\u503c\u7684\u5b57\u5178\uff08\u4e5f\u53eb multidict\uff09\uff1f", url: "#multidict", children: [
          ]},
          {title: "\u4f60\u60f3\u521b\u5efa\u4e00\u4e2a\u5b57\u5178\uff0c\u5e76\u4e14\u5728\u8fed\u4ee3\u6216\u5e8f\u5217\u5316\u8fd9\u4e2a\u5b57\u5178\u7684\u65f6\u5019\u80fd\u591f\u63a7\u5236\u5143\u7d20\u7684\u987a\u5e8f\u3002", url: "#_2", children: [
          ]},
          {title: "\u600e\u6837\u5728\u6570\u636e\u5b57\u5178\u4e2d\u6267\u884c\u4e00\u4e9b\u8ba1\u7b97\u64cd\u4f5c\uff08\u6bd4\u5982\u6c42\u6700\u5c0f\u503c\u3001\u6700\u5927\u503c\u3001\u6392\u5e8f\u7b49\u7b49\uff09\uff1f", url: "#_3", children: [
          ]},
          {title: "\u600e\u6837\u5728\u4e24\u4e2a\u5b57\u5178\u4e2d\u5bfb\u5bfb\u627e\u76f8\u540c\u70b9\uff08\u6bd4\u5982\u76f8\u540c\u7684\u952e\u3001\u76f8\u540c\u7684\u503c\u7b49\u7b49\uff09\uff1f", url: "#_4", children: [
          ]},
          {title: "\u600e\u6837\u5728\u4e00\u4e2a\u5e8f\u5217\u4e0a\u9762\u4fdd\u6301\u5143\u7d20\u987a\u5e8f\u7684\u540c\u65f6\u6d88\u9664\u91cd\u590d\u7684\u503c\uff1f", url: "#_5", children: [
          ]},
          {title: "\u5982\u679c\u4f60\u7684\u7a0b\u5e8f\u5305\u542b\u4e86\u5927\u91cf\u65e0\u6cd5\u76f4\u89c6\u7684\u786c\u7f16\u7801\u5207\u7247\uff0c\u5e76\u4e14\u4f60\u60f3\u6e05\u7406\u4e00\u4e0b\u4ee3\u7801\u3002", url: "#_6", children: [
          ]},
          {title: "\u600e\u6837\u627e\u51fa\u4e00\u4e2a\u5e8f\u5217\u4e2d\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u5462\uff1f", url: "#_7", children: [
          ]},
          {title: "\u4f60\u6709\u4e00\u4e2a\u5b57\u5178\u5217\u8868\uff0c\u4f60\u60f3\u6839\u636e\u67d0\u4e2a\u6216\u67d0\u51e0\u4e2a\u5b57\u5178\u5b57\u6bb5\u6765\u6392\u5e8f\u8fd9\u4e2a\u5217\u8868\u3002", url: "#_8", children: [
          ]},
          {title: "\u4f60\u60f3\u6392\u5e8f\u7c7b\u578b\u76f8\u540c\u7684\u5bf9\u8c61\uff0c\u4f46\u662f\u4ed6\u4eec\u4e0d\u652f\u6301\u539f\u751f\u7684\u6bd4\u8f83\u64cd\u4f5c\u3002", url: "#_9", children: [
          ]},
          {title: "\u4f60\u6709\u4e00\u4e2a\u5b57\u5178\u6216\u8005\u5b9e\u4f8b\u7684\u5e8f\u5217\uff0c\u7136\u540e\u4f60\u60f3\u6839\u636e\u67d0\u4e2a\u7279\u5b9a\u7684\u5b57\u6bb5\u6bd4\u5982 date \u6765\u5206\u7ec4\u8fed\u4ee3\u8bbf\u95ee\u3002", url: "#date", children: [
          ]},
          {title: "\u4f60\u6709\u4e00\u4e2a\u6570\u636e\u5e8f\u5217\uff0c\u60f3\u5229\u7528\u4e00\u4e9b\u89c4\u5219\u4ece\u4e2d\u63d0\u53d6\u51fa\u9700\u8981\u7684\u503c\u6216\u8005\u662f\u7f29\u77ed\u5e8f\u5217", url: "#_10", children: [
          ]},
          {title: "\u4f60\u60f3\u6784\u9020\u4e00\u4e2a\u5b57\u5178\uff0c\u5b83\u662f\u53e6\u5916\u4e00\u4e2a\u5b57\u5178\u7684\u5b50\u96c6\u3002", url: "#_11", children: [
          ]},
          {title: "\u4f60\u6709\u4e00\u6bb5\u901a\u8fc7\u4e0b\u6807\u8bbf\u95ee\u5217\u8868\u6216\u8005\u5143\u7ec4\u4e2d\u5143\u7d20\u7684\u4ee3\u7801\uff0c\u4f46\u662f\u8fd9\u6837\u6709\u65f6\u5019\u4f1a\u4f7f\u5f97\u4f60\u7684\u4ee3\u7801\u96be\u4ee5\u9605\u8bfb\uff0c \u4e8e\u662f\u4f60\u60f3\u901a\u8fc7\u540d\u79f0\u6765\u8bbf\u95ee\u5143\u7d20\u3002", url: "#_12", children: [
          ]},
          {title: "\u4f60\u9700\u8981\u5728\u6570\u636e\u5e8f\u5217\u4e0a\u6267\u884c\u805a\u96c6\u51fd\u6570\uff08\u6bd4\u5982 sum() , min() , max() \uff09\uff0c \u4f46\u662f\u9996\u5148\u4f60\u9700\u8981\u5148\u8f6c\u6362\u6216\u8005\u8fc7\u6ee4\u6570\u636e", url: "#sum-min-max", children: [
          ]},
          {title: "\u73b0\u5728\u6709\u591a\u4e2a\u5b57\u5178\u6216\u8005\u6620\u5c04\uff0c\u4f60\u60f3\u5c06\u5b83\u4eec\u4ece\u903b\u8f91\u4e0a\u5408\u5e76\u4e3a\u4e00\u4e2a\u5355\u4e00\u7684\u6620\u5c04\u540e\u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\uff0c \u6bd4\u5982\u67e5\u627e\u503c\u6216\u8005\u68c0\u67e5\u67d0\u4e9b\u952e\u662f\u5426\u5b58\u5728\u3002", url: "#_13", children: [
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../chapter2/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../chapter2/" class="btn btn-xs btn-link">
        第二章
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../python/logging/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../python/logging/" class="btn btn-xs btn-link">
        logging模块学习
      </a>
    </div>
    
  </div>

    

    <h1 id="n-n"><strong>现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？</strong></h1>
<pre><code class="language-python">p = (4,5)
x,y = p
print(x,y) 
</code></pre>
<pre><code>4 5
</code></pre>
<h1 id="valueerror-n"><strong>如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 ValueError 。 那么怎样才能从这个可迭代对象中解压出 N 个元素出来？</strong></h1>
<pre><code class="language-python">data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
name,shares,price,(year,*date) = data
name,year,date
</code></pre>
<pre><code>('ACME', 2012, [12, 21])
</code></pre>
<pre><code class="language-python">data = ['wlb',18,18265090197,131232141]
name,age,*phone = data
print(name,age,phone)
</code></pre>
<pre><code>wlb 18 [18265090197, 131232141]
</code></pre>
<pre><code class="language-python">*trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
print(trailing,current)
</code></pre>
<pre><code>[10, 8, 7, 1, 9, 5, 10] 3
</code></pre>
<h1 id="_1"><strong>在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？</strong></h1>
<pre><code class="language-python">from collections import deque
q = deque(maxlen=3) #限制长度
q.append(1)
q.append(2)
q.append(3)
q
</code></pre>
<pre><code>deque([1, 2, 3])
</code></pre>
<pre><code class="language-python">q.append(4)
q
</code></pre>
<pre><code>deque([2, 3, 4])
</code></pre>
<pre><code class="language-python">q.append(5)
q
</code></pre>
<pre><code>deque([3, 4, 5])
</code></pre>
<pre><code class="language-python">q = deque()
q.append(1)
q.append(2)
q.append(3)
q.appendleft(4)
q
</code></pre>
<pre><code>deque([4, 1, 2, 3])
</code></pre>
<pre><code class="language-python">q.pop()
</code></pre>
<pre><code>3
</code></pre>
<pre><code class="language-python">q.popleft()
</code></pre>
<pre><code>4
</code></pre>
<h1 id="n"><strong>怎样从一个集合中获得最大或者最小的 N 个元素列表？</strong></h1>
<pre><code class="language-python">import heapq
nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3,nums)) #最大的三个数
</code></pre>
<pre><code>[42, 37, 23]
</code></pre>
<pre><code class="language-python">print(heapq.nsmallest(3,nums)) #最小的三个数
</code></pre>
<pre><code>[-4, 1, 2]
</code></pre>
<pre><code class="language-python">portfolio = [{'name': 'IBM', 'shares': 100, 'price': 91.1},{'name': 'AAPL', 'shares': 50, 'price': 543.22},   {'name': 'FB', 'shares': 200, 'price': 21.09},   {'name': 'HPQ', 'shares': 35, 'price': 31.75},   {'name': 'YHOO', 'shares': 45, 'price': 16.35},   {'name': 'ACME', 'shares': 75, 'price': 115.65}]
print(heapq.nlargest(3,portfolio,lambda s:s['price']))
print(heapq.nsmallest(3,portfolio,lambda s:s['price']))
</code></pre>
<pre><code>[{'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'ACME', 'shares': 75, 'price': 115.65}, {'name': 'IBM', 'shares': 100, 'price': 91.1}]
[{'name': 'YHOO', 'shares': 45, 'price': 16.35}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}]
</code></pre>
<pre><code class="language-python">nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
import heapq

heap = list(nums)
heapq.heapify(heap)
heap
</code></pre>
<pre><code>[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
</code></pre>
<p><strong>堆最重要的特性就是heap[0]总是最小那个的元素。此外，接下来的元素可依次通过heapq.heappop()方法轻松找到。该方法会将第一个元素（最小的）弹出，然后以第二小的元素取而代之（这个操作的复杂度是O(logN)，N代表堆的大小）</strong></p>
<pre><code class="language-python">heapq.heappop(heap)
</code></pre>
<pre><code>-4
</code></pre>
<pre><code class="language-python">heap
</code></pre>
<pre><code>[1, 2, 2, 23, 7, 8, 18, 23, 42, 37]
</code></pre>
<pre><code class="language-python">heapq.heappop(heap)
</code></pre>
<pre><code>1
</code></pre>
<h1 id="pop"><strong>怎样实现一个按优先级排序的队列？ 并且在这个队列上面每次 pop 操作总是返回优先级最高的那个元素</strong></h1>
<p><strong>实现一个优先级队列</strong></p>
<pre><code class="language-python">import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]
</code></pre>
<pre><code class="language-python">class Item:
    def __init__(self,name):
        self.name = name
    def __repr__(self):
        return f&quot;Item('{self.name}')&quot;
q = PriorityQueue()
q.push(Item('foo'),1)
q.push(Item('bar'),5)
q.push(Item('spam'),4)
q.push(Item('grok'),1)
q._queue
</code></pre>
<pre><code>[(-5, 1, Item('bar')),
 (-1, 0, Item('foo')),
 (-4, 2, Item('spam')),
 (-1, 3, Item('grok'))]
</code></pre>
<pre><code class="language-python">q.pop()
</code></pre>
<pre><code>Item('bar')
</code></pre>
<pre><code class="language-python">q._queue
</code></pre>
<pre><code>[(-4, 2, Item('spam')), (-1, 0, Item('foo')), (-1, 3, Item('grok'))]
</code></pre>
<pre><code class="language-python">q.pop()
</code></pre>
<pre><code>Item('spam')
</code></pre>
<pre><code class="language-python">q._queue
</code></pre>
<pre><code>[(-1, 0, Item('foo')), (-1, 3, Item('grok'))]
</code></pre>
<h1 id="multidict"><strong>怎样实现一个键对应多个值的字典（也叫 multidict）？</strong></h1>
<pre><code class="language-python">from collections import defaultdict
d = defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)
d
</code></pre>
<pre><code>defaultdict(list, {'a': [1, 2], 'b': [4]})
</code></pre>
<pre><code class="language-python">d = defaultdict(set)
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)
d
</code></pre>
<pre><code>defaultdict(set, {'a': {1, 2}, 'b': {4}})
</code></pre>
<p><strong>对比</strong></p>
<pre><code class="language-python">d = {}
for key, value in pairs:
    if key not in d:
        d[key] = []
    d[key].append(value)
</code></pre>
<pre><code class="language-python">d = defaultdict(list)
for key, value in pairs:
    d[key].append(value)
</code></pre>
<h1 id="_2"><strong>你想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。</strong></h1>
<pre><code class="language-python">#为了能控制一个字典中元素的顺序，你可以使用 collections 模块中的 OrderedDict 类。 在迭代操作的时候它会保持元素被插入时的顺序
from collections import OrderedDict
d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4
for k,v in d.items():
    print(k,v)
</code></pre>
<pre><code>foo 1
bar 2
spam 3
grok 4
</code></pre>
<h1 id="_3"><strong>怎样在数据字典中执行一些计算操作（比如求最小值、最大值、排序等等）？</strong></h1>
<pre><code class="language-python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
</code></pre>
<pre><code class="language-python">min_price = min(zip(prices.values(), prices.keys())) #用zip反转
min_price
</code></pre>
<pre><code>(10.75, 'FB')
</code></pre>
<pre><code class="language-python">max_price = max(zip(prices.values(),prices.keys()))
max_price
</code></pre>
<pre><code>(612.78, 'AAPL')
</code></pre>
<pre><code class="language-python">#也可以排序
sorted(zip(prices.values(),prices.keys()))
</code></pre>
<pre><code>[(10.75, 'FB'),
 (37.2, 'HPQ'),
 (45.23, 'ACME'),
 (205.55, 'IBM'),
 (612.78, 'AAPL')]
</code></pre>
<pre><code class="language-python">prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names)) # OK
print(max(prices_and_names)) # ValueError: max() arg is an empty sequence
#意思就是zip()生成的是只能访问一次的迭代器
</code></pre>
<pre><code class="language-python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
#max 和 min 也可以传入key 以获得符合自己条件的最大最小值
print(max(prices,key=lambda k:prices[k]),min(prices,key=lambda k:prices[k]))
#根据values获取最大最小值的键
#这样如果想获取值还要进行取值操作prices[xxx],所以上面的zip是最好的选择
</code></pre>
<pre><code>AAPL FB
</code></pre>
<h1 id="_4"><strong>怎样在两个字典中寻寻找相同点（比如相同的键、相同的值等等）？</strong></h1>
<pre><code class="language-python">a = {
    'x' : 1,
    'y' : 2,
    'z' : 3
}

b = {
    'w' : 10,
    'x' : 11,
    'y' : 2
}
#如果找到两个字典重复的键?
#可以使用交集操作
</code></pre>
<pre><code class="language-python">a.keys() &amp; b.keys()
</code></pre>
<pre><code>{'x', 'y'}
</code></pre>
<pre><code class="language-python">a.items() &amp; b.items()
</code></pre>
<pre><code>{('y', 2)}
</code></pre>
<pre><code class="language-python">#假如你想以现有字典构造一个排除几个指定键的新字典。 下面利用字典推导来实现这样的需求
c = {key:a[key] for key in a.keys() - {'z', 'w'}}
# c is {'x': 1, 'y': 2}
</code></pre>
<h1 id="_5"><strong>怎样在一个序列上面保持元素顺序的同时消除重复的值？</strong></h1>
<pre><code class="language-python">def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)
#只适用于对象是可哈希的            
</code></pre>
<h1 id="_6"><strong>如果你的程序包含了大量无法直视的硬编码切片，并且你想清理一下代码。</strong></h1>
<pre><code class="language-python">record = '....................100 .......513.25 ..........'
cost = int(record[20:23]) * float(record[31:37])
cost
</code></pre>
<pre><code>51325.0
</code></pre>
<pre><code class="language-python">SHARES = slice(20, 23)
PRICE = slice(31, 37)
cost = int(record[SHARES]) * float(record[PRICE])
cost
</code></pre>
<pre><code>51325.0
</code></pre>
<p><strong>显然第二种方法可维护性更强</strong></p>
<pre><code class="language-python">items = [0, 1, 2, 3, 4, 5, 6]
a = slice(2,4)
print(items[2:4],items[a])
</code></pre>
<pre><code>[2, 3] [2, 3]
</code></pre>
<pre><code class="language-python">items[a] = [10,11]
items
</code></pre>
<pre><code>[0, 1, 10, 11, 4, 5, 6]
</code></pre>
<pre><code class="language-python">a = slice(5,50,2)
a.start,a.stop,a.step
</code></pre>
<pre><code>(5, 50, 2)
</code></pre>
<pre><code class="language-python">#你还可以通过调用切片的 indices(size) 方法将它映射到一个已知大小的序列上。 这个方法返回一个三元组 (start, stop, step) ，所有的值都会被缩小，直到适合这个已知序列的边界为止。
s = 'HelloWorld'
a.indices(len(s))
</code></pre>
<pre><code>(5, 10, 2)
</code></pre>
<pre><code class="language-python">for i in range(*a.indices(len(s))): #将a解包
    print(s[i])
</code></pre>
<pre><code>W
r
d
</code></pre>
<h1 id="_7"><strong>怎样找出一个序列中出现次数最多的元素呢？</strong></h1>
<pre><code class="language-python">#答案是collections.Counter()
words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
    'eyes', &quot;don't&quot;, 'look', 'around', 'the', 'eyes', 'look', 'into',
    'my', 'eyes', &quot;you're&quot;, 'under'
]
from collections import Counter
word_counts = Counter(words)
word_counts
</code></pre>
<pre><code>Counter({'around': 2,
         "don't": 1,
         'eyes': 8,
         'into': 3,
         'look': 4,
         'my': 3,
         'not': 1,
         'the': 5,
         'under': 1,
         "you're": 1})
</code></pre>
<pre><code class="language-python">top_three = word_counts.most_common(3) #出现最多的三个单词
print(top_three)
</code></pre>
<pre><code>[('eyes', 8), ('the', 5), ('look', 4)]
</code></pre>
<pre><code class="language-python">#如果想增加次数
morewords = ['why','are','you','not','looking','in','my','eyes']
word_counts.update(morewords)
word_counts
</code></pre>
<pre><code>Counter({'are': 1,
         'around': 2,
         "don't": 1,
         'eyes': 9,
         'in': 1,
         'into': 3,
         'look': 4,
         'looking': 1,
         'my': 4,
         'not': 2,
         'the': 5,
         'under': 1,
         'why': 1,
         'you': 1,
         "you're": 1})
</code></pre>
<pre><code class="language-python">a = Counter(words)
b = Counter(morewords)
print(a)
print(b)
</code></pre>
<pre><code>Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2, 'not': 1, "don't": 1, "you're": 1, 'under': 1})
Counter({'why': 1, 'are': 1, 'you': 1, 'not': 1, 'looking': 1, 'in': 1, 'my': 1, 'eyes': 1})
</code></pre>
<pre><code class="language-python">c = a + b #Counter生成对象可以加法运算 一般字典不能进行加法运算
c
</code></pre>
<pre><code>Counter({'are': 1,
         'around': 2,
         "don't": 1,
         'eyes': 9,
         'in': 1,
         'into': 3,
         'look': 4,
         'looking': 1,
         'my': 4,
         'not': 2,
         'the': 5,
         'under': 1,
         'why': 1,
         'you': 1,
         "you're": 1})
</code></pre>
<pre><code class="language-python">d = a - b #减法运算
d
</code></pre>
<pre><code>Counter({'around': 2,
         "don't": 1,
         'eyes': 7,
         'into': 3,
         'look': 4,
         'my': 2,
         'the': 5,
         'under': 1,
         "you're": 1})
</code></pre>
<h1 id="_8"><strong>你有一个字典列表，你想根据某个或某几个字典字段来排序这个列表。</strong></h1>
<pre><code class="language-python">rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
sorted(rows,key=lambda x:x['uid'])
</code></pre>
<pre><code>[{'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
 {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
 {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
 {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}]
</code></pre>
<pre><code class="language-python">from operator import itemgetter
rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))
print(rows_by_fname)
print(rows_by_uid)
</code></pre>
<pre><code>[{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}, {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003}, {'fname': 'David', 'lname': 'Beazley', 'uid': 1002}, {'fname': 'John', 'lname': 'Cleese', 'uid': 1001}]
[{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}, {'fname': 'David', 'lname': 'Beazley', 'uid': 1002}, {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003}, {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}]
</code></pre>
<pre><code class="language-python">rows_by_lfname = sorted(rows, key=itemgetter('lname','fname')) #传入多个参数
print(rows_by_lfname)
</code></pre>
<pre><code>[{'fname': 'David', 'lname': 'Beazley', 'uid': 1002}, {'fname': 'John', 'lname': 'Cleese', 'uid': 1001}, {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}, {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003}]
</code></pre>
<pre><code class="language-python">min(rows, key=itemgetter('uid'))
</code></pre>
<pre><code>{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
</code></pre>
<pre><code class="language-python">min(rows,key = lambda x:x['uid'])
</code></pre>
<pre><code>{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
</code></pre>
<p><strong>上述列子说明,lambda和operator.itemgetter()实现的结果是一样的,但调用库速度快一点</strong></p>
<h1 id="_9"><strong>你想排序类型相同的对象，但是他们不支持原生的比较操作。</strong></h1>
<pre><code class="language-python">class User:
    def __init__(self, user_id):
        self.user_id = user_id

    def __repr__(self):
        return 'User({})'.format(self.user_id)


def sort_notcompare():
    users = [User(23), User(3), User(99)]
    print(users)
    print(sorted(users, key=lambda u: u.user_id))
sort_notcompare()
</code></pre>
<pre><code>[User(23), User(3), User(99)]
[User(3), User(23), User(99)]
</code></pre>
<h1 id="date"><strong>你有一个字典或者实例的序列，然后你想根据某个特定的字段比如 date 来分组迭代访问。</strong></h1>
<pre><code class="language-python">from itertools import groupby
rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]
rows.sort(key=lambda x:x['date']) #注意要事先排序
for date, items in groupby(rows, key=itemgetter('date')):
    print(date)
    for i in items:
        print(' ', i)
</code></pre>
<pre><code>07/01/2012
  {'address': '5412 N CLARK', 'date': '07/01/2012'}
  {'address': '4801 N BROADWAY', 'date': '07/01/2012'}
07/02/2012
  {'address': '5800 E 58TH', 'date': '07/02/2012'}
  {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'}
  {'address': '1060 W ADDISON', 'date': '07/02/2012'}
07/03/2012
  {'address': '2122 N CLARK', 'date': '07/03/2012'}
07/04/2012
  {'address': '5148 N CLARK', 'date': '07/04/2012'}
  {'address': '1039 W GRANVILLE', 'date': '07/04/2012'}
</code></pre>
<pre><code class="language-python">#用groupby之前必须要先排好序,在每次迭代的时候，它会返回一个值和一个迭代器对象
#如果你仅仅只是想根据 date 字段将数据分组到一个大的数据结构中去，并且允许随机访问， 那么你最好使用 defaultdict() 来构建一个多值字典
from collections import defaultdict
rows_by_date = defaultdict(list)
for row in rows:
    rows_by_date[row['date']].append(row)
for d in rows_by_date['07/04/2012']:
    print(d)
</code></pre>
<pre><code>{'address': '5148 N CLARK', 'date': '07/04/2012'}
{'address': '1039 W GRANVILLE', 'date': '07/04/2012'}
</code></pre>
<h1 id="_10"><strong>你有一个数据序列，想利用一些规则从中提取出需要的值或者是缩短序列</strong></h1>
<pre><code class="language-python">mylist = [1, 4, -5, 10, -7, 2, 3, -1]
#最简单的就是列表推导了
[n for n in mylist if n &gt; 0]
</code></pre>
<pre><code>[1, 4, 10, 2, 3]
</code></pre>
<pre><code class="language-python">#显然会占用大量内存,这时候可以选择用生成器
pos = (n for n in mylist if n &gt; 0)
pos
</code></pre>
<pre><code>&lt;generator object &lt;genexpr&gt; at 0x0000022DE651DBA0&gt;
</code></pre>
<pre><code class="language-python">#但这两种方法又不够优雅,我追求的是优雅的完成任务,所以用到了filter
print(filter(lambda x:x &gt; 0,mylist))
print(list(filter(lambda x :x &gt; 0,mylist)))
</code></pre>
<pre><code>&lt;filter object at 0x0000022DE66E5198&gt;
[1, 4, 10, 2, 3]
</code></pre>
<pre><code class="language-python">#另外一个值得关注的过滤工具就是 itertools.compress() ， 它以一个 iterable 对象和一个相对应的 Boolean 选择器序列作为输入参数。 然后输出 iterable 对象中对应选择器为 True 的元素。
addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK',
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]
counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
from itertools import compress
more5 = [n &gt; 5 for n in counts]
list(compress(addresses, more5))
</code></pre>
<pre><code>['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
</code></pre>
<pre><code class="language-python">#在看书时,我想到了别的方法
d = dict(zip(addresses,counts))
list(filter(lambda x:d[x] &gt; 5,d))
</code></pre>
<pre><code>['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
</code></pre>
<h1 id="_11"><strong>你想构造一个字典，它是另外一个字典的子集。</strong></h1>
<pre><code class="language-python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
# Make a dictionary of all prices over 200
p1 = {key: value for key, value in prices.items() if value &gt; 200}
# Make a dictionary of tech stocks
tech_names = {'AAPL', 'IBM', 'HPQ', 'MSFT'}
p2 = {key: value for key, value in prices.items() if key in tech_names}
print(p1)
print(p2)
</code></pre>
<pre><code>{'AAPL': 612.78, 'IBM': 205.55}
{'AAPL': 612.78, 'IBM': 205.55, 'HPQ': 37.2}
</code></pre>
<h1 id="_12"><strong>你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读， 于是你想通过名称来访问元素。</strong></h1>
<pre><code class="language-python">from collections import namedtuple
Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
sub = Subscriber('jonesy@example.com','2021-01-02')
sub.addr,sub.joined
</code></pre>
<pre><code>('jonesy@example.com', '2021-01-02')
</code></pre>
<pre><code class="language-python">data = namedtuple('data', ['name', 'year', 'height'])
lists = ['wlb',18,180]
sub = data(*lists)
sub.year
</code></pre>
<pre><code>18
</code></pre>
<pre><code class="language-python">#想修改不能直接修改,要调用方法
sub = sub._replace(height=190)
sub
</code></pre>
<pre><code>data(name='wlb', year=18, height=190)
</code></pre>
<h1 id="sum-min-max"><strong>你需要在数据序列上执行聚集函数（比如 sum() , min() , max() ）， 但是首先你需要先转换或者过滤数据</strong></h1>
<pre><code class="language-python">nums = [1, 2, 3, 4, 5]
s = sum(x * x for x in nums)
</code></pre>
<pre><code class="language-python">s
</code></pre>
<pre><code>55
</code></pre>
<pre><code class="language-python">s = sum((x * x for x in nums)) # 显式的传递一个生成器表达式对象
s = sum(x * x for x in nums) # 更加优雅的实现方式，省略了括号
</code></pre>
<p><strong>在使用一些聚集函数比如 min() 和 max() 的时候你可能更加倾向于使用生成器版本， 它们接受的一个 key 关键字参数或许对你很有帮助</strong></p>
<h1 id="_13"><strong>现在有多个字典或者映射，你想将它们从逻辑上合并为一个单一的映射后执行某些操作， 比如查找值或者检查某些键是否存在。</strong></h1>
<pre><code class="language-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
</code></pre>
<pre><code class="language-python">from collections import ChainMap
c = ChainMap(a,b)
print(c['x']) # Outputs 1 (from a)
print(c['y']) # Outputs 2 (from b)
print(c['z']) # Outputs 3 (from a)
</code></pre>
<pre><code>1
2
3
</code></pre>
<p><strong>如果出现重复键，那么第一次出现的映射值会被返回。 因此，例子程序中的 c['z'] 总是会返回字典 a 中对应的值，而不是 b 中对应的值。</strong></p>
<p><strong>作为 ChainMap 的替代，你可能会考虑使用 update() 方法将两个字典合并.</strong>
<strong>这样也能行得通，但是它需要你创建一个完全不同的字典对象（或者是破坏现有字典结构）。 同时，如果原字典做了更新，这种改变不会反应到新的合并字典中去。</strong></p>
<p><strong>ChainMap 使用原来的字典，它自己不创建新的字典。所以它并不会产生上面所说的结果，</strong></p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../chapter2/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../chapter2/" class="btn btn-xs btn-link">
        第二章
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../python/logging/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../python/logging/" class="btn btn-xs btn-link">
        logging模块学习
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>