<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="vllbc">
    <link rel="canonical" href="https://vllbc.github.io/python/WTF/">
    <link rel="shortcut icon" href="../../1.ico">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>WTFpython学习 - Vllbc's home</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u5fae\u5999\u7684\u5b57\u7b26\u4e32", url: "#_top", children: [
          ]},
          {title: "\u662f\u65f6\u5019\u6765\u70b9\u86cb\u7cd5\u4e86!", url: "#_2", children: [
          ]},
          {title: "\u672c\u8d28\u4e0a,\u6211\u4eec\u90fd\u4e00\u6837", url: "#_3", children: [
          ]},
          {title: "\u4e3a\u4ec0\u4e48\uff1f", url: "#_4", children: [
          ]},
          {title: "\u5217\u8868\u526f\u672c", url: "#_5", children: [
          ]},
          {title: "\u6267\u884c\u65f6\u673a\u5dee\u5f02", url: "#_6", children: [
          ]},
          {title: "\u51fa\u4eba\u610f\u6599\u7684is", url: "#is", children: [
          ]},
          {title: "\u4e00\u8e74\u5373\u81f3!", url: "#_7", children: [
          ]},
          {title: "\u9ebb\u70e6\u7684\u8f93\u51fa", url: "#_8", children: [
          ]},
          {title: "\u8fdePython\u4e5f\u77e5\u9053\u7231\u662f\u96be\u8a00\u7684", url: "#python", children: [
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../pyqt/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../pyqt/" class="btn btn-xs btn-link">
        pyqt学习
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../skill/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../skill/" class="btn btn-xs btn-link">
        技巧
      </a>
    </div>
    
  </div>

    

    <h1 id="_1"><strong>微妙的字符串</strong></h1>
<pre><code class="python">a = 'some_thing'
b = 'some'+'_'+'thing'
id(a),id(b)
</code></pre>

<pre><code>(1957716471920, 1957716471920)
</code></pre>
<pre><code class="python">a = 'wtf'
b = 'wtf'
a is b
</code></pre>

<pre><code>True
</code></pre>
<pre><code class="python">a = 'wtf!'
b = 'wtf!'
a is b
</code></pre>

<pre><code>False
</code></pre>
<pre><code class="python">a,b = 'wtf!','wtf!'
a is b
</code></pre>

<pre><code>True
</code></pre>
<pre><code class="python">'a'*20 is 'aaaaaaaaaaaaaaaaaaaa','a'*21 is 'aaaaaaaaaaaaaaaaaaaaa'
</code></pre>

<pre><code>(True, False)
</code></pre>
<p><strong>Cpython 在编译优化时, 某些情况下会尝试使用已经存在的不可变对象,成为字符串驻留</strong>
 <strong>发生驻留之后, 许多变量可能指向内存中的相同字符串对象</strong>
 <strong>所有长度为 0 和长度为 1 的字符串都被驻留.</strong></p>
<p><strong>字符串在编译时被实现 ('wtf' 将被驻留, 但是 ''.join(['w', 't', 'f'] 将不会被驻留)</strong>
<strong>字符串中只包含字母，数字或下划线时将会驻留. 所以 'wtf!' 由于包含 ! 而未被驻留。</strong></p>
<p><strong>当在同一行将 a 和 b 的值设置为 "wtf!" 的时候, Python 解释器会创建一个新对象, 然后同时引用第二个变量.</strong></p>
<p><strong>常量折叠(constant folding) 是 Python 中的一种 窥孔优化(peephole optimization) 技术. 这意味着在编译时表达式 'a'*20 会被替换为 'aaaaaaaaaaaaaaaaaaaa' 以减少运行时的时钟周期. 只有长度小于 20 的字符串才会发生常量折叠.</strong> </p>
<pre><code class="python">a = 1
b = 1
a is b,id(a) == id(b)
</code></pre>

<pre><code>(True, True)
</code></pre>
<p><strong>is 是比较对象是否相同(is 表示对象标识符即 object identity)，即用 id() 函数查看的地址是否相同，如果相同则返回 True，如果不同则返回 False。is 不能被重载。</strong></p>
<p><strong>== 是比较两个对象的值是否相等，此操作符内部调用的是 _eq() 方法。所以 a==b 等效于a._eq(b)，所以 = 可以被重载</strong></p>
<h1 id="_2"><strong>是时候来点蛋糕了!</strong></h1>
<pre><code class="python">some_dict = {}
some_dict[5.5] = 'ruby'
some_dict[5.0] = 'javascript'
some_dict[5] = 'python'
print(some_dict[5.0])
</code></pre>

<pre><code>python
</code></pre>
<pre><code class="python">5 == 5.0,hash(5) == hash(5.0)
</code></pre>

<pre><code>(True, True)
</code></pre>
<p><strong>Python 字典通过检查键值是否相等和比较哈希值来确定两个键是否相同.</strong>
<strong>具有相同值的不可变对象在Python中始终具有相同的哈希值</strong></p>
<h1 id="_3"><strong>本质上,我们都一样</strong></h1>
<pre><code class="python">class WTF:
    pass
print(WTF() == WTF(),WTF() is WTF())
print(hash(WTF()) == hash(WTF()))
print(id(WTF()) == id(WTF()))
</code></pre>

<pre><code>False False
True
True
</code></pre>
<p><strong>当调用 id 函数时, Python 创建了一个 WTF 类的对象并传给 id 函数. 然后 id 函数获取其id值 (也就是内存地址), 然后丢弃该对象. 该对象就被销毁了.</strong></p>
<p><strong>当我们连续两次进行这个操作时, Python会将相同的内存地址分配给第二个对象. 因为 (在CPython中) id 函数使用对象的内存地址作为对象的id值, 所以两个对象的id值是相同的.</strong></p>
<pre><code class="python">print(id(id(WTF())) == id(id(WTF()))) #无论多少个ID都是True 原因就在上面
#虽然id(id(WTF())) == id(id(WTF())) 但是id(WTF()) is id(WTF()) 返回True
#原因就是id这个函数调用的过程特殊性
print(id(WTF()) is id(WTF())) 
</code></pre>

<pre><code>True
False
</code></pre>
<pre><code class="python">class WTF(object):
    def __init__(self): 
        print(&quot;I&quot;)
    def __del__(self): 
        print(&quot;D&quot;)
</code></pre>

<pre><code class="python">WTF() is WTF() #这时是两个对象一起创建，然后一起销毁，所以id不一样
</code></pre>

<pre><code>I
I
D
D





False
</code></pre>
<pre><code class="python">id(WTF()) == id(WTF()) #这时候先创建一个销毁，然后再创建。对象销毁的顺序是造成所有不同之处的原因.
</code></pre>

<pre><code>I
D
I
D





True
</code></pre>
<h1 id="_4"><strong>为什么？</strong></h1>
<pre><code class="python">some_string = &quot;wtf&quot;
some_dict = {}
for i, some_dict[i] in enumerate(some_string):
    pass
</code></pre>

<pre><code class="python">some_dict
</code></pre>

<pre><code>{0: 'w', 1: 't', 2: 'f'}
</code></pre>
<pre><code class="python">for i in range(4):
    print(i)
    i = 10
</code></pre>

<pre><code>0
1
2
3
</code></pre>
<h1 id="_5"><strong>列表副本</strong></h1>
<pre><code class="python">list1 = [1,2,3,4,5]
list2 = list1
list2[0] = 6
print(list1,list2)
</code></pre>

<pre><code>[6, 2, 3, 4, 5] [6, 2, 3, 4, 5]
</code></pre>
<pre><code class="python">list1 = [1,2,3,4,5]
list2 = list1[:]
list2[0] = 6
print(list1,list2)
</code></pre>

<pre><code>[1, 2, 3, 4, 5] [6, 2, 3, 4, 5]
</code></pre>
<h1 id="_6"><strong>执行时机差异</strong></h1>
<pre><code class="python">array = [1, 8, 15]
g = (x for x in array if array.count(x) &gt; 0) #这时候x为[1,8,15]的解包
#而后面的array变成了下面的
array = [2, 8, 22]
print(list(g))
</code></pre>

<pre><code>[8]
</code></pre>
<p><strong>在生成器表达式中, in 子句在声明时执行, 而条件子句则是在运行时执行.</strong>
<strong>所以在运行前, array 已经被重新赋值为 [2, 8, 22], 因此对于之前的 1, 8 和 15, 只有 count(8) 的结果是大于 0 的, 所以生成器只会生成 8.</strong></p>
<pre><code class="python">array_1 = [1,2,3,4]
g1 = (x for x in array_1)
array_1 = [1,2,3,4,5]

array_2 = [1,2,3,4]
g2 = (x for x in array_2)
array_2[:] = [1,2,3,4,5]
print(list(g1))
print(list(g2))
</code></pre>

<pre><code>[1, 2, 3, 4]
[1, 2, 3, 4, 5]
</code></pre>
<p><strong>第二部分中 g1 和 g2 的输出差异则是由于变量 array_1 和 array_2 被重新赋值的方式导致的.</strong></p>
<p><strong>在第一种情况下, array_1 被绑定到新对象 [1,2,3,4,5], 因为 in 子句是在声明时被执行的， 所以它仍然引用旧对象 <a href="并没有被销毁">1,2,3,4</a>.</strong></p>
<p><strong>在第二种情况下, 对 array_2 的切片赋值将相同的旧对象 [1,2,3,4] 原地更新为 [1,2,3,4,5]. 因此 g2 和 array_2 仍然引用同一个对象(这个对象现在已经更新为 [1,2,3,4,5]).</strong></p>
<h1 id="is"><strong>出人意料的is</strong></h1>
<pre><code class="python">a = 256
b = 256
a is b
</code></pre>

<pre><code>True
</code></pre>
<pre><code class="python">a = 257 
b = 257  #256 是一个已经存在的对象, 而 257 不是
#当你启动Python 的时候, -5 到 256 的数值就已经被分配好了.
#这些数字因为经常使用所以适合被提前准备好
a is b
</code></pre>

<pre><code>False
</code></pre>
<pre><code class="python">a,b = 257,257 #当 a 和 b 在同一行中使用相同的值初始化时，会指向同一个对象.
print(a is b)
print(id(a),id(b))
</code></pre>

<pre><code>True
1957717387056 1957717387056
</code></pre>
<pre><code class="python">[] == []
</code></pre>

<pre><code>True
</code></pre>
<pre><code class="python">[] is [] #两个空列表位于不同的内存地址
</code></pre>

<pre><code>False
</code></pre>
<h1 id="_7"><strong>一蹴即至!</strong></h1>
<pre><code class="python">row = [&quot;&quot;] * 3
board = [row] * 3
board
</code></pre>

<pre><code>[['', '', ''], ['', '', ''], ['', '', '']]
</code></pre>
<pre><code class="python">board[0][0] = 'X'
board #这是因为之前对row做乘法导致的
</code></pre>

<pre><code>[['X', '', ''], ['X', '', ''], ['X', '', '']]
</code></pre>
<pre><code class="python">#如何避免这种情况？
board = [['']*3 for _ in range(3)]
board[0][0] = 'X'
board
</code></pre>

<pre><code>[['X', '', ''], ['', '', ''], ['', '', '']]
</code></pre>
<h1 id="_8"><strong>麻烦的输出</strong></h1>
<pre><code class="python">funcs = []
res = []
for x in range(7):
    def func():
        return x
    funcs.append(func)
    res.append(func())
func_res = [func() for func in funcs]
print(func_res,res)
</code></pre>

<pre><code>[6, 6, 6, 6, 6, 6, 6] [0, 1, 2, 3, 4, 5, 6]
</code></pre>
<pre><code class="python">power_x = [lambda x:x**i for i in range(11)]
print([func(2) for func in power_x])
</code></pre>

<pre><code>[1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024]
</code></pre>
<p><strong>在循环内部定义一个函数时, 如果该函数在其主体中使用了循环变量, 则闭包函数将与循环变量绑定, 而不是它的值. 因此, 所有的函数都是使用最后分配给变量的值来进行计算的.</strong></p>
<h1 id="python"><strong>连Python也知道爱是难言的</strong></h1>
<pre><code class="python">import this
</code></pre>

<pre><code>The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</code></pre>
<pre><code class="python">love = this
</code></pre>

<pre><code class="python">this is love
</code></pre>

<pre><code>True
</code></pre>
<pre><code class="python">love is True
</code></pre>

<pre><code>False
</code></pre>
<pre><code class="python">love is False
</code></pre>

<pre><code>False
</code></pre>
<pre><code class="python">love is not True or False
</code></pre>

<pre><code>True
</code></pre>
<pre><code class="python">love is not True or False;love is love
</code></pre>

<pre><code>True
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../pyqt/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../pyqt/" class="btn btn-xs btn-link">
        pyqt学习
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../skill/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../skill/" class="btn btn-xs btn-link">
        技巧
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>