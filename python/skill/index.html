<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="vllbc">
    <link rel="canonical" href="https://vllbc.github.io/python/skill/">
    <link rel="shortcut icon" href="../../1.ico">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>技巧 - Vllbc's home</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u4e24\u4e2a\u6570\u7684\u4ea4\u6362", url: "#_top", children: [
          ]},
          {title: "\u683c\u5f0f\u5316\u5b57\u7b26\u4e32", url: "#_2", children: [
          ]},
          {title: "Yield\u7528\u6cd5", url: "#yield", children: [
          ]},
          {title: "\u5217\u8868\u89e3\u6790\u5f0f", url: "#_3", children: [
          ]},
          {title: "enumerate", url: "#enumerate", children: [
          ]},
          {title: "\u5b57\u5178\u7684\u5408\u5e76", url: "#_4", children: [
          ]},
          {title: "\u5e8f\u5217\u89e3\u5305", url: "#_5", children: [
          ]},
          {title: "\u533f\u540d\u51fd\u6570lambda", url: "#lambda", children: [
          ]},
          {title: "\u88c5\u9970\u5668", url: "#_6", children: [
          ]},
          {title: "map\u548creduce", url: "#mapreduce", children: [
          ]},
          {title: "join()", url: "#join", children: [
          ]},
          {title: "\u5c06\u591a\u7ef4\u6570\u7ec4\u8f6c\u6362\u4e3a\u4e00\u7ef4", url: "#_7", children: [
          ]},
          {title: "\u5c06\u4e00\u4e2a\u5217\u8868\u5012\u5e8f", url: "#_8", children: [
          ]},
          {title: "\u68c0\u67e5\u4e24\u4e2a\u5217\u8868\u4e2d\u6240\u6709\u7684\u6570\u662f\u5426\u4e00\u6837", url: "#_9", children: [
          ]},
          {title: "\u968f\u673a\u751f\u6210\u5bc6\u7801", url: "#_10", children: [
          ]},
          {title: "filter", url: "#filter", children: [
          ]},
          {title: "\u65ad\u8a00", url: "#_11", children: [
          ]},
          {title: "\u5408\u5e76\u5217\u8868", url: "#_12", children: [
          ]},
          {title: "\u5bf9\u8fdb\u884c\u89e3\u5305", url: "#_13", children: [
          ]},
          {title: "\u5bf9\u7c7b\u7684\u4e00\u4e9b\u64cd\u4f5c", url: "#_14", children: [
          ]},
          {title: "\u4e00\u4e9b\u5185\u7f6e\u51fd\u6570", url: "#_15", children: [
          ]},
          {title: "functools.partial", url: "#functoolspartial", children: [
          ]},
          {title: "@classmethod\u548c@staticmethod", url: "#classmethodstaticmethod", children: [
          ]},
          {title: "\u7528\u7c7b\u5b9e\u73b0\u88c5\u9970\u5668", url: "#_16", children: [
          ]},
          {title: "BaseModel", url: "#basemodel", children: [
          ]},
          {title: "python\u7c7b\u578b\u6ce8\u91ca", url: "#python", children: [
          ]},
          {title: "namedtuple", url: "#namedtuple", children: [
          ]},
          {title: "@property", url: "#property", children: [
          ]},
          {title: "\u5728\u8fb9\u754c\u5904\u601d\u8003", url: "#_17", children: [
          ]},
          {title: "super()\u8fdb\u9636", url: "#super", children: [
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../WTF/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../WTF/" class="btn btn-xs btn-link">
        WTFpython学习
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../asyncio/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../asyncio/" class="btn btn-xs btn-link">
        asyncio模块异步编程
      </a>
    </div>
    
  </div>

    

    <h1 id="_1"><strong>两个数的交换</strong></h1>
<pre><code class="python"># a = 1
# b = 2
# temp = b
# b = a
# a = temp
# print(a,b)

a = 1
b = 2
a,b = b,a
print(a,b)
</code></pre>

<pre><code>2 1
</code></pre>
<h1 id="_2"><strong>格式化字符串</strong></h1>
<pre><code class="python">a = 17
name = &quot;wlb&quot;
# print('%s is %d years old' %  (name,a))
# print('{} is {} years old'.format(name,a))
print(f'{name} is {a} years old') #明显这个方法更简单
</code></pre>

<pre><code>wlb is 17 years old
</code></pre>
<h1 id="yield"><strong>Yield用法</strong></h1>
<pre><code class="python">def fib(n):
    a = 0
    b = 1
#     lists = []
    for _ in range(n):
#         lists.append(a)
        yield  a
        a,b = b,a+b
#     return lists
for i in fib(10):
    print(i)
#注释的内容与yield a效果相同，yield相当于使其成为一个迭代器 yield一个数后会立马传递出去，而return 要等列表都生成完毕后才会传出去
#他的优势在于一些耗时的操作
</code></pre>

<pre><code>0
1
1
2
3
5
8
13
21
34
</code></pre>
<h1 id="_3"><strong>列表解析式</strong></h1>
<pre><code class="python">lists = [f&quot;http://www.baidu.com/page{n}&quot; for n in range(21)]
lists#此方法在爬虫构造urls中非常常用
# lists = [f&quot;http://www.baidu.com/page{n}&quot; for n in range(21) if n%2==0] page偶数
# alp = &quot;abcdefghigklmnopqrstuvwxyz&quot;
# ALP = [n.upper() for n in alp] 将小写转换为大写
</code></pre>

<pre><code>['http://www.baidu.com/page0',
 'http://www.baidu.com/page1',
 'http://www.baidu.com/page2',
 'http://www.baidu.com/page3',
 'http://www.baidu.com/page4',
 'http://www.baidu.com/page5',
 'http://www.baidu.com/page6',
 'http://www.baidu.com/page7',
 'http://www.baidu.com/page8',
 'http://www.baidu.com/page9',
 'http://www.baidu.com/page10',
 'http://www.baidu.com/page11',
 'http://www.baidu.com/page12',
 'http://www.baidu.com/page13',
 'http://www.baidu.com/page14',
 'http://www.baidu.com/page15',
 'http://www.baidu.com/page16',
 'http://www.baidu.com/page17',
 'http://www.baidu.com/page18',
 'http://www.baidu.com/page19',
 'http://www.baidu.com/page20']
</code></pre>
<h1 id="enumerate"><strong>enumerate</strong></h1>
<pre><code class="python">lists = ['apple','banana','cat','dog']
#enumerate相当于一个压包的过程，相当于zip(range(len(lists)),lists)
for index,name in enumerate(lists):
    print(index,name)
</code></pre>

<pre><code>0 apple
1 banana
2 cat
3 dog
</code></pre>
<h1 id="_4"><strong>字典的合并</strong></h1>
<pre><code class="python">dic1 = {'qq':1683070754,
        'phone':123456789
       }
dic2 = {
    'height':180,
    'handsome':True
}
dic3 = {**dic1,**dic2}
#合并两个字典 **叫做解包
#或者用dic1.update(dic2) 将dic2合并到dic1 相同键则dic2替代dic1
dic3
</code></pre>

<pre><code>{'handsome': True, 'height': 180, 'phone': 123456789, 'qq': 1683070754}
</code></pre>
<h1 id="_5"><strong>序列解包</strong></h1>
<pre><code class="python">name = &quot;wang lingbo&quot;
xing,ming = name.split(&quot; &quot;) #split返回一个序列，分别赋给xing 和ming
print(xing,ming)
#x,*y,z = [1,2,3,4,5]
#x:1 z:5 y:[2,3,4]
</code></pre>

<pre><code>wang lingbo
</code></pre>
<h1 id="lambda"><strong>匿名函数lambda</strong></h1>
<pre><code class="python">lists = [1,2,3,4,5,6]
maps = map(lambda x:x*x,lists)
print(maps)
print(list(maps))
</code></pre>

<pre><code>&lt;map object at 0x000001911C8E03C8&gt;
[1, 4, 9, 16, 25, 36]
</code></pre>
<h1 id="_6"><strong>装饰器</strong></h1>
<pre><code class="python">def logging(level):
    def wapper(func):
        def inner_wapper(*args, **wbargs):
            print(f'{level}  enter in {func.__name__}()')
            return func(*args, **wbargs) #不写return 也可以
        return inner_wapper
    return wapper
@logging('inner')
def say(a):
    print('hello!  {}'.format(a))
say('wlb')
</code></pre>

<pre><code>inner  enter in say()
hello!  wlb
</code></pre>
<pre><code class="python">import time
def print_time(func):
    def wapper(*args,**wbargs):
        print(f'{func.__name__}()调用于{time.asctime(time.localtime(time.time()))}')
        return func(*args,**wbargs) #不写return 也可以
    return wapper
@print_time
def my_name(name):
    print(f'look!{name}')
my_name(&quot;wlb&quot;)
</code></pre>

<pre><code>my_name()调用于Wed Dec  9 21:21:00 2020
look!wlb
</code></pre>
<h1 id="mapreduce"><strong>map和reduce</strong></h1>
<pre><code class="python">print(list(map(abs,[-1,-2,-3,-4,-5]))) #也可以自己定义函数或者用匿名函数
from functools import reduce #python3中需要从内置库导入

print(reduce(lambda x,y:x+y,list(map(int,str(131351412)))))
</code></pre>

<pre><code>[1, 2, 3, 4, 5]
21
</code></pre>
<h1 id="join"><strong>join()</strong></h1>
<pre><code class="python"># lists = ['1','2','3','4','5']
# ''.join(lists)
lists = [1,2,3,4,5]
''.join(list(map(str,lists))) #join只能是字符串列表，所以要map转换一下
</code></pre>

<pre><code>'12345'
</code></pre>
<h1 id="_7"><strong>将多维数组转换为一维</strong></h1>
<pre><code class="python">ab = [[1, 2, 3], [5, 8], [7, 8, 9]]
print([i for item in ab for i in item]) #利用列表解析式
print(sum(ab, [])) # 利用sum函数
from functools import reduce
print(reduce(lambda x,y:x+y,ab)) # 利用reduce
from itertools import chain
print(list(chain(*ab))) # 利用chain

def flatten(items,ignore=(str,bytes)):
    for x in items:
        if isinstance(x,Iterable) and not isinstance(x,ignore):
            yield from flatten(x)
        else:
            yield x
print(list(flatten(ab))) # 利用自己定义的函数
</code></pre>

<pre><code>[1, 2, 3, 5, 8, 7, 8, 9]
</code></pre>
<h1 id="_8"><strong>将一个列表倒序</strong></h1>
<pre><code class="python">lists = [2,4,3,2,5,4]
lists[::-1]
# list(reversed(lists))
</code></pre>

<pre><code>[4, 5, 2, 3, 4, 2]
</code></pre>
<h1 id="_9"><strong>检查两个列表中所有的数是否一样</strong></h1>
<pre><code class="python">lists = [1,1,1,1]
lists[1:] == lists[:-1]
</code></pre>

<pre><code>True
</code></pre>
<h1 id="_10"><strong>随机生成密码</strong></h1>
<pre><code class="python">import random
b = 8
t = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'
print(''.join(random.sample(t,b)))
</code></pre>

<pre><code>0KmtEZSU
</code></pre>
<h1 id="filter"><strong>filter</strong></h1>
<pre><code class="python">a = [1,2,3,4,5,6,7,8,9]
new_a = filter(lambda x:x%2!=0,a) #filter就是筛选
list(new_a)
</code></pre>

<pre><code>[1, 3, 5, 7, 9]
</code></pre>
<h1 id="_11"><strong>断言</strong></h1>
<pre><code class="python">assert(True is True) #成功
print('yes')
assert(True is False) #报错
print('no')
</code></pre>

<pre><code>yes
</code></pre>
<h1 id="_12"><strong>合并列表</strong></h1>
<pre><code class="python">list1 = [1,2,31,13]
list2 = [5,2,12,32]
# list1.append(list2)
# print(list1) #错误方法
list1.extend(list2)
print(list1) #正确方法
</code></pre>

<pre><code>[1, 2, 31, 13, 5, 2, 12, 32]
</code></pre>
<pre><code class="python">a = [1,2,3,4,5]
b = ['a','b','c','d','e']
fin = dict()
for k,i in zip(a,b):
    fin[k] = i
print(fin)

# 或者
fin = dict(zip(a,b))
print(fin)
</code></pre>

<pre><code>{1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}
</code></pre>
<h1 id="_13">对<list>进行解包</h1>
<pre><code class="python">lists = ['dog','cat','you']
print(*lists)
#想对一个列表进行zip操作时，可以这样
print(list(zip(*lists)))
def test(*args):
    print(&quot;args:&quot;,args)
test(*lists)
</code></pre>

<pre><code>dog cat you
[('d', 'c', 'y'), ('o', 'a', 'o'), ('g', 't', 'u')]
args:('dog','cat','you')
</code></pre>

<h1 id="_14">对类的一些操作</h1>
<pre><code class="python">class Test:
    x = 1
    y = 2
print(Test.x,Test.y) #==&gt;print(Test().x,Test().y)
class Test:
    def __init__(self,x,y):
        self.x = x
        self.y = y
test = Test(1,2)
print(test.x,test.y)
</code></pre>

<pre><code>1 2
1 2
</code></pre>

<pre><code class="python">class Test:
    def __init__(self,maxlen):
        self.maxlen = maxlen
        self.lists = []
    def put(self,*args):
        for i in args:
            if len(self.lists) &lt;= self.maxlen:
                self.lists.append(i)
            else:
                break
    def get(self):
        return self.lists.pop()
    def empty(self):
        if len(self.lists) != 0:
            return False
        else:
            return True
    def __len__(self):
        return len(self.lists)
    def __del__(self):
        print(&quot;del this class&quot;)
    def printfs(self):
        return self.lists
test = Test(10)
test.put(1,2,3,4,5,6)
print(test.empty())
print(len(test))
print(test.printfs())
test.__del__()   #直接调用test还存在，__del__是析构函数，垃圾回收时就会调用a
print(test)
#del test
#print(test) 这时候就会报错，因为del将test这个对象直接删除了
</code></pre>

<pre><code>False
6
[1, 2, 3, 4, 5, 6]
del this class
&lt;__main__.Test object at 0x0000021B7DF33EB0&gt;
del this class
</code></pre>

<h1 id="_15">一些内置函数</h1>
<pre><code class="python">all([True,True,False]) #False
all([True,True,True]) #True
any([True,True,False]) #True
any([True,False,False])#True
any([False,False]) #False
</code></pre>

<pre><code class="python">import random
for i in iter(lambda:random.randint(1,10),5):
    print(i)

#相当于
while True:
    x = random.randint(1,10)
    print(x)
    if x == 5:
        break
</code></pre>

<pre><code class="markdown">iter(object[, sentinel])
sentinel为可选参数，若不传入，则object必须为可迭代对象，传入则必须为可调用对象,当可调用对象的返回值为sentinel抛出异常，但for循环会处理这个异常，这常常用于IO操作
</code></pre>

<p>​       </p>
<pre><code class="python">#这是cookbook里面的一个例子
import sys
f = open('xxx/xxx.txt')
for chunk in iter(lambda:f.read(10),''):
    n = sys.stdout.write(chunk)
</code></pre>

<pre><code class="python">#深入理解一下
import random
class Test:
    def __init__(self):
        self.lists = [1,23,2,4,1,421,412]
    def __call__(self):
        return random.choice(self.lists)
for i in iter(Test(),1):
    print(i)
#这是可以正常输出的，因为实例化Test后是个可调用对象，返回列表的随机值，当返回1时则循环结束，如果把__call__魔法方法去了后，则会报错，如果想要不使用魔法方法的话可以用匿名函数
import random
class Test:
    def __init__(self):
        self.lists = [1,23,2,4,1,421,412]
    # def __call__(self):
    #     return random.choice(self.lists)
for i in iter(lambda:random.choice(Test().lists),1):
    print(i)
#总之，吹爆cookbook
</code></pre>

<h1 id="functoolspartial">functools.partial</h1>
<pre><code class="python">#先看演示
from functools import partial
def add(a,b):
    return a + b
addOne = partial(add,1)
addOne(2) #3
addOne(4) #5
#大概意思就是利用partial将函数的一个参数固定住了
</code></pre>

<pre><code class="python">def partial(func,*wargs):
    def wapper(*kargs):
        args = list(wargs)
        print(f&quot;args:{args}&quot;)
        print(f&quot;kargs:{kargs}&quot;)
        args.extend(wargs)
        print(f&quot;last:{args}&quot;)
        return func(*args)
    return wapper

def add(a,b,c):
    return a + b + c

addone = partial(add,1,2) #此时addone相当于wapper
print(addone(3)) #调用wrapper 3为传入的kargs
#输出：
args:[1, 2]
kargs:(3,)
last:[1, 2, 3]
6

#上面是partial函数的简化版本
#很明显的闭包操作，很容易就可以理解
#当然也可以转换为装饰器操作
</code></pre>

<pre><code class="python">from functools import wraps

def out_wapper(*wargs):
    def partial(func):
        @wraps(func)
        def wrapper(*kargs):
            args = list(wargs)
            print(f&quot;args:{args}&quot;)
            print(f&quot;kargs:{kargs}&quot;)
            args.extend(kargs)
            print(f&quot;last:{args}&quot;)
            return func(*args)
        return wrapper
    return partial
#这个是装饰器版本的
@out_wapper(1,2)
def add(a,b,c):
    return a + b + c

print(add(3)) #输出和上面一样
#明显装饰器要麻烦一点实现，不过毕竟是封装好的函数，以后直接用就可以，不过了解这些有助于提高思维水平
</code></pre>

<h1 id="classmethodstaticmethod">@classmethod和@staticmethod</h1>
<pre><code class="python">class A(object):
    bar = 1
    def func1(self):  
        print ('foo') 
    @classmethod
    def func2(cls):
        print ('func2')
        print (cls.bar)
        cls().func1()   # 调用 foo 方法

A.func2()               # 不需要实例化
</code></pre>

<pre><code>func2
1
foo
</code></pre>

<pre><code class="python">class A(object):

    # 属性默认为类属性（可以给直接被类本身调用）
    num = &quot;类属性&quot;

    # 实例化方法（必须实例化类之后才能被调用）
    def func1(self): # self : 表示实例化类后的地址id
        print(&quot;func1&quot;)
        print(self)

    # 类方法（不需要实例化类就可以被类本身调用）
    @classmethod
    def func2(cls):  # cls : 表示没用被实例化的类本身
        print(&quot;func2&quot;)
        print(cls)
        print(cls.num)
        cls().func1()

    # 不传递传递默认self参数的方法（该方法也是可以直接被类调用的，但是这样做不标准）
    def func3():
        print(&quot;func3&quot;)
        print(A.num) # 属性是可以直接用类本身调用的

# A.func1() 这样调用是会报错：因为func1()调用时需要默认传递实例化类后的地址id参数，如果不实例化类是无法调用的
A.func2()
A.func3() 
</code></pre>

<pre><code class="python">class A(object):
    def foo(self, x):
        print(&quot;executing foo(%s,%s)&quot; % (self, x))
        print('self:', self)
    @staticmethod
    def static_foo(x):
        print(&quot;executing static_foo(%s)&quot; % x)   
</code></pre>

<pre><code class="markdown">问题：@staticmethod修饰的方法函数与普通的类外函数，为什么不直接使用普通函数？
@staticmethod是把函数嵌入到类中的一种方式，函数就属于类，同时表明函数不需要访问这个类。通过子类的继承覆盖，能更好的组织代码。
</code></pre>

<h1 id="_16">用类实现装饰器</h1>
<pre><code class="python">#先看这样的代码  类实现装饰器要求类必须是可调用的
import time
import functools


class DelayFunc:
    def __init__(self,  duration, func):
        self.duration = duration
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f'Wait for {self.duration} seconds...')
        time.sleep(self.duration)
        return self.func(*args, **kwargs)

    def eager_call(self, *args, **kwargs):
        print('Call without delay')
        return self.func(*args, **kwargs)


def delay(duration):
    &quot;&quot;&quot;装饰器：推迟某个函数的执行。同时提供 .eager_call 方法立即执行
    &quot;&quot;&quot;
    # 此处为了避免定义额外函数，直接使用 functools.partial 帮助构造
    # DelayFunc 实例
    return functools.partial(DelayFunc, duration)
@delay(2)
def add(a,b):
    print(a,b)
add(1,2) #延迟两秒输出3
add.eager_call(1,2) #不延迟输出3
#理解：
#装饰器的作用就是把add函数实例化为上述类的实例
#就是DelayFunc(add,2).__call__(1,2)
#有个更通俗的写法，就是手动实现partial
def delay(duration):
    def partial(func,*args):
        def wrapper(*targs):
            return func(*(args+targs))
        return wrapper
    return partial(DelayFunc,duration) #此时duration已经传进去了 还缺少一个参数func，而targs用于传入func，这就是装饰器的体现之处
上面装饰器的写法也可以这样写
def add(a,b):
    print(a+b)
delay(2)(add)(1,2)
</code></pre>

<pre><code class="python">#额，当然，想更深入理解的话，也可以这么写
def delay(duration):
    def partial(func):
        return DelayFunc(duration,func)
    return partial

@delay(2)
def add(a,b):
    return a + b
print(add(1,2))
</code></pre>

<h1 id="basemodel">BaseModel</h1>
<pre><code class="python">from pydantic import BaseModel,AnyUrl


class Test(BaseModel): # 继承后可以用类属性创建实例
    url: AnyUrl
    data: str

    def __str__(self):
        return self.url + self.data


kwargs = {
    'url': 'https://www.baidu.com',
    'data': '/search'
}
print(Test(**kwargs))
</code></pre>

<h1 id="python">python类型注释</h1>
<pre><code class="python">from pydantic import BaseModel
from typing import Any


class cout():
    def __init__(self, cls: &quot;Test&quot;, text: str) -&gt; None: 
        self.cls = cls
        self.text = text

    def __str__(self):
        return f&quot;{self.cls}  {self.text}&quot;
#程序到cout时 Test类并没有定义，但最后Test在变量空间中，所以加上引号

class Test(BaseModel):
    def __str__(self) -&gt; str:
        return &quot;I am Test Class&quot;


print(cout(cls=Test(), text=&quot;hello world!&quot;))
</code></pre>

<h1 id="namedtuple">namedtuple</h1>
<pre><code class="python">from collections import namedtuple

Test = namedtuple(&quot;Test&quot;, ['name', 'age', 'sex'])

def test_for_test(name: str, year: int, sex: str) -&gt; &quot;Test&quot;:
    return Test(
        name=name.title(),
        age=2021 - year,
        sex=sex
    )

name,age,sex = test_for_test('wlb', 2002, 'male')
print(name, age, sex)
</code></pre>

<h1 id="property">@property</h1>
<pre><code class="python">from pydantic import BaseModel
#其实就是防止属性被修改，通俗说加上这个装饰器就不能在后面加()了

class Test():

    def __init__(self, cls, n):
        self.cls = cls
        self.n = n 
    @property
    def to_string(self):
        return self.cls

    @property
    def to_strings(self):
        return self.n


class Test_For(BaseModel):
    num: int

    def __str__(self):
        return str(self.num)

    __repr__ = __str__

test = Test(Test_For, 22)
print(test.to_string(num=1))
print(test.to_strings)
</code></pre>

<h1 id="_17">在边界处思考</h1>
<pre><code class="python">from typing import Iterable
from pydantic import BaseModel,conint,ValidationError


class NumberInput(BaseModel):
    num: conint(ge=0, le=100)


def input_a_number():
    while True:
        n = input(&quot;输入一个数&quot;)
        try:
            n = NumberInput(num=n)
        except ValidationError as e:
            print(e)
            continue
        n = n.num
        break
    return n

print(input_a_number()) #要求输入一个0-100的数 这样是不是很优雅
</code></pre>

<h1 id="super">super()进阶</h1>
<p>今天学习cookbook8-8<code>子类中扩展property</code>  先贴一下代码</p>
<pre><code class="python">class Person:
    def __init__(self, name):
        self.name = name # 有意思的是 这里的self.name是@property修饰的 这行代码调用name.setter

    # Getter function
    @property
    def name(self):
        return self._name

    # Setter function
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._name = value

    # Deleter function
    @name.deleter
    def name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)



# 子类

class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
</code></pre>

<p>看到super(SubPerson, SubPerson)感到很疑惑，于是搜索资料大致搞明白了</p>
<p>通俗说默认的super(SubPerson,self) (直接写super()也可) 返回的是一个类的实例</p>
<blockquote>
<p>为了委托给之前定义的setter方法，需要将控制权传递给之前定义的name属性的 <code>__set__()</code> 方法。 不过，获取这个方法的唯一途径是使用类变量而不是实例变量来访问它。 这也是为什么我们要使用 <code>super(SubPerson, SubPerson)</code> 的原因。</p>
</blockquote>
<p>从书中这句话可以看出 super(cls,cls)返回的是一个类 不是一个实例，super()的参数的作用就是用于定位位置</p>
<p>第一个cls必须是第二cls的父类或者二者相同，可以通过<code>cls.__mro__</code>查看继承顺序 比如在D里面<code>super(A,D).__init__(self)</code></p>
<p>而<code>__mro__</code> 为 <code>(&lt;class '__main__.D'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;)</code> 那么就调用从A以后的类的<code>__init__()</code></p>
<p>不过重点不在这里，重点是super(cls,cls)和super(cls,object)的区别</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../WTF/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../WTF/" class="btn btn-xs btn-link">
        WTFpython学习
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../asyncio/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../asyncio/" class="btn btn-xs btn-link">
        asyncio模块异步编程
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>