# 各描述表与系统调用过程

决定考研了，专业课要考操作系统，我也没有系统学过，就记录一下学习笔记，看的hit的网课，书看的《操作系统概念》，然后再针对性的刷题吧。

(所有内容的前提都是没有引入页的概念，只在段的层面上进行)

## 寻址

对于段来说，寻址可以采用段基址+偏移的形式寻址物理内存，在实模式下，使用段基址*16+偏移的方式寻址，这是因为寄存器位数与地址总线宽度不平衡，但是对于保护模式来说，即用户使用的模式，这样的寻址方式能力有限，因为为了适应之前的版本，CS等段基址只能使用16位，因此在保护模式下引入了GDT，用于保存段描述符。

## GDT

GDT在内存中有且仅有一个，它是一个描述符**数组**，每个描述符8个字节。
![](image/Pasted%20image%2020230312224400.png)

在保护模式下，CS等段寄存器意义已然发生了改变，其中高13位保存了段选择子，用于从GDT中找到相应的描述符，描述符的具体信息后面再说。13位的段选择子，因此代表了GDT中最多可以有$2^{13}=8192$个描述符。第2位存储了TI值（0代表GDT、1代表LDT，LDT后面再说，与GDT功能类似，不过在内存中可以有多个，而且可以对于不同的任务都有不同的LDT），第0、1位存储了当前的特权级（CPL）。
![](image/Pasted%20image%2020230312224858.png)

其中GDT的位置从GDTR寄存器中得到。

## GDTR
![](image/Pasted%20image%2020230312225023.png)
GDTR寄存器为6字节，前两个字节为GDT界限，后4个字节为GDT表的基地址。

## GDT描述符的细节

前面说了一个描述符占8个字节，包含三个部分：
- 段基址（32位），占据描述符的第16～39位和第55位～63位，前者存储低16位，后者存储高16位
- 段界限（20位），占据描述符的第0～15位和第48～51位，前者存储低16位，后者存储高4位。
- 段属性（12位），占据描述符的第39～47位和第49～55位，段属性可以细分为8种：TYPE属性、S属性、DPL属性、P属性、AVL属性、L属性、D/B属性和G属性。

![](image/Pasted%20image%2020230312225152.png)

### S属性
S属性存储了描述符的类型

- S=0 时，该描述符对应的段是系统段（System Segment）。
- S=1 时，该描述符对应的段是数据段（Data Segment）或者代码段
### TYPE属性
TYPE属性存储段的类型信息，该属性的意义随着S属性不同而不同。
当 S=1 （该段为数据段或代码段）时，需要分为两种情况：
- 当TYPE属性第三位为0时，代表该段为数据段，第0～2位的作用为：
![](image/Pasted%20image%2020230322100409.png)
- 当TYPE属性第3位为1时，代表该段为代码段，第0～2位的作用为：
![](image/Pasted%20image%2020230322100531.png)
一致代码段的“一致”意思是：当CPU执行jmp等指令将CS寄存器指向该代码段时，如果当前的特权级低于该代码段的特权级，那么当前的特权级会被延续下去（简单的说就是可以被低特权级的用户直接访问的代码），如果当前的特权级高于该代码段的特权级，那么会触发常规保护错误（可以理解为内核态下不允许直接执行用户态的代码）。
如果不是一致代码段并且该代码段的特权级不等于（高于和低于都不行）当前的特权级，那么会引发常规保护错误。
- 当 S=0 （该段为系统段）时：
![](image/Pasted%20image%2020230322100646.png)

### DLP属性
DPL属性占2个比特，记录了访问段所需要的特权级，特权级范围为0～3，越小特权级越高。
### P属性
P属性标记了该段是否存在：

- P = 0 时，该段在内存中不存在
- P = 1  时，该段在内存中存在
尝试访问一个在内存中不存在的段会触发段不存在错误（#NP）

### AVL属性
AVL属性占1个比特，该属性的意义可由操作系统、应用程序自行定义。  
Intel保证该位不会被占用作为其他用途。
### L属性
该属性仅在IA-32e模式下有意义，它标记了该段是否为64位代码段。
当L = 1  时，表示该段是64位代码段。
如果设置了L属性为1，则必须保证D属性为0。

### D/B属性
D/B属性中的D/B全称 Default operation size / Default stack pointer size / Upper bound。
该属性的意义随着段描述符是代码段（Code Segment）、向下扩展数据段（Expand-down Data Segment）还是栈段（Stack Segment）而有所不同。
-   代码段（S属性为1，TYPE属性第三位为1）  如果对应的是代码段，那么该位称之为D属性（D flag）。如果设置了该属性，那么会被视为32位代码段执行；如果没有设置，那么会被视为16位代码段执行。
- 栈段（被SS寄存器指向的数据段）  该情况下称之为B属性。如果设置了该属性，那么在执行堆栈访问指令（例如`PUSH`、`POP`指令）时采用32位堆栈指针寄存器（ESP寄存器），如果没有设置，那么采用16位堆栈指针寄存器（SP寄存器）。
- 向下扩展的数据段  该情况下称之为B属性。如果设置了该属性，段的上界为4GB，否则为64KB。
### G属性
G属性记录了段界限的粒度：

G = 0  时，段界限的粒度为字节
G = 1 时，段界限的粒度为4KB
例如，当G = 0 并且描述符中的段界限值为10000 ，那么该段的界限为10000字节，如果G = 1 ，那么该段的界限值为40000KB。
所以说，当G = 0 时，一个段的最大界限值为1MB（因为段界限只能用20位表示，
），最小为1字节（段的大小等于段界限值加1）。
当G = 1  时，最大界限值为4GB，最小为4KB。

在访问段（除栈段）时，如果超出了段的界限，那么会触发常规保护错误（#GP）
如果访问栈段超出了界限，那么会产生堆栈错误（#SS）

## LDT

LDT也是描述符表，和GDT一样，不过LDT的描述符信息保存在GDT中
关系如下：
![](image/Pasted%20image%2020230312230604.png)

LDT本身是一个段，而GDT是一个数组。GDT只能有一个，LDT可以有很多个。

查找GDT在线性地址中的基地址，需要借助GDTR；而查找LDT相应基地址，需要的是GDT中的段描述符。访问LDT需要使用段选择符，为了减少访问LDT时候的段转换次数，LDT的段选择符，段基址，段限长都要放在LDTR寄存器之中。选择符是可见的，而基址等信息都是不可见的。可以通过lldt命令来修改LDTR以改变在GDT中选择的LDT，因为LDTR的本质也是一个选择子。当修改选择子时，会自动从GDT中获得相关的信息，并保存在高速缓存器中，这样可以加速访问速度。
![](image/Pasted%20image%2020230312232312.png)
TR用于寻址一个特殊的任务状态段（TaskState Segment，TSS）。TSS中包含着当前执行任务的重要信息。后面会说。

由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问。

GDT和LDT在内存中关系如下：
![](image/Pasted%20image%2020230312231847.png)

## IDT
中断描述符表类似全局描述附表，表内存放的描述符，与GDT不同的是IDT内可以存放4种描述符：任务门描述符，陷阱门描述符，调用门描述符，中断门描述符。

下面是中断门描述符
![](image/Pasted%20image%2020230319192357.png)
IDT也是由段选择子进行选择的，不过这里的段选择子就是所谓的中断号，对应如下表：
![](image/Pasted%20image%2020230321211906.png)

相应的，计算机中也有对应的IDTR寄存器用于存储IDT在内存中的位置。存放的是48位数据信息，高32位是IDT的地址，低16位表示IDT的界限。

## TSS
在一个多任务环境中，当发生了任务切换，需保护现场，因此每个任务的应当用一个额外的[内存](https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020)区域保存相关信息，即任务状态段(TSS)；TSS格式固定，104个字节，处理器固件能识别TSS中元素，并在任务切换时读取其中信息。每个任务都配有一个TSS，TSS基地址、界限等信息可以存放在任务对应的TCB中；
通过任务寄存器**TR**进行定位；  TR选择子在前面已经看过了，和LDTR是一样的。
将TSS视为一种特殊的内存段，则可为每一个TSS创建一个**TSS描述符**，将描述符存放到GDT中；
各部分关系图：
![](image/Pasted%20image%2020230321233903.png)

TSS描述符存放在GDT中；
![](image/Pasted%20image%2020230321233935.png)

TYPE中'B'：忙，刚创建时应为0，任务开始执行，挂起时为1，由硬件管理，防止切换任务切到自己；TSS描述符DPL必须为0，只有CPL为0能调用；
TSS结构如下：
![](image/Pasted%20image%2020230321233954.png)
一共占据104个字节。
各部分作用如下：
![](image/Pasted%20image%2020230321234102.png)
注意96，因为每个任务都有自己的LDT，则每个任务的段寄存器基本上都从各自任务的LDT中查找描述符。
## 系统调用过程
以系统调用为例，系统调用的底层必然是一个中断即int x80，属于是内部中断，当中断发生时，将CPU中断寄存器置位，以此表明产生了中断。CPU在执行完一条指令之后，检测到有中断信号，如果中断没有屏蔽，则根据中断号，跳转到中断描述符表中指明的中断处理程序的位置。在前面的中断向量表中就可以看到x80对应的中断处理程序入口就是系统调用程序，当执行完所有这些步骤后（可能调度也可能不调度），会回到中断发生后的指令继续执行，所以在发生中断时需要进行现场保护。

CPU据中断向量号去IDT中获取中断描述符，取出选择子中的DPL与当前特权级CPL进行比较，若特权级发生变化，则需要切换栈。（不同特权级有着不同的栈，如Linux使用了0， 3特权级，则有两个栈，一个内核栈，一个用户栈）

于是处理器临时保存当前的旧栈SS和ESP的值，从TSS（每一个任务有一个TSS结构，其中保存着不同特权级栈的SS和ESP值）中获取与DPL特权级同的栈信息加载到SS和ESP寄存器。再将旧栈SS和ESP的值压入新栈中。若没有特权级变化，则跳过此步骤。

![](image/Pasted%20image%2020230322093805.png)

压入程序状态信息，即EFLAGS寄存器
![](image/Pasted%20image%2020230322093819.png)
压入断点，即返回地址，即当前任务的CS，EIP值。
![](image/Pasted%20image%2020230322093827.png)

若该中断有错误码，压入错误码

![](image/Pasted%20image%2020230322093836.png)
注意上述压栈操作都是硬件自动完成的。
总结图如下：
![](image/Pasted%20image%2020230322094314.png)

然后通过下图定位中断处理程序：
![](image/Pasted%20image%2020230322093913.png)

因为IDT中每个描述符都是8个字节，因此中断向量号要*8，选择子同理。
对于系统调用，中断处理程序如下：
```c
/* 此处已进入进程内核栈 */
ENTRY(system_call)
	pushl %eax			// save orig_eax，此处为系统调用号
	SAVE_ALL            // 保存上下文
	GET_THREAD_INFO(%ebp)
	// system call tracing in operation
	testb $(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT),TI_flags(%ebp)
	jnz syscall_trace_entry
	cmpl $(nr_syscalls), %eax  //nr_syscalls表示最大的系统调用号加1。eax存放的是用户传进来的系统调用号。
	jae syscall_badsys
	//系统调用号确定有效后
syscall_call:
	call *sys_call_table(,%eax,4)  // 在sys_call_table中查找系统调用号对应的程序并执行。
	movl %eax,EAX(%esp)		// 保存返回值
syscall_exit:
	cli				/* 
					make sure we don't miss an interrupt
					setting need_resched or sigpending
					between sampling and the iret 
					*/
	movl TI_flags(%ebp), %ecx
	testw $_TIF_ALLWORK_MASK, %cx	// current->work
	jne syscall_exit_work
restore_all:
	RESTORE_ALL     // 恢复上下文
	// perform work that needs to be done immediately before resumption

```

如果系统调用会造成进程的调度，那么会将下一行命令的内存地址放入栈中（一般来说是中断返回），当前cpu的各种寄存器值放入当前进程的tss表，然后将要切换的进程的tss表中的信息赋给cpu中的各种寄存器，以此实现了进程的切换。再次调度回来时也同理，然后会继续执行没有执行完的代码。
### 中断屏蔽
Linux将中断处理程序分为上下两部分，需要紧急处理立即执行的归为上半部，不那么紧急的归为下半部。

这便涉及到了开关中断的问题。开中断，即EFLAGS的IF位置1，表示允许响应中断；关中断，即EFLAGS的IF位置0，表示不允许响应中断。
1、上半部分是刻不容缓的，需要立即执行的部分，所以要在关中断的状态下执行。

2、而下半部分不那么紧急，在开中断的情况下进行，如果此时有新的中断发生，当前中断处理程序便会换下CPU，CPU会另寻时间重新调度，完成整个中断处理程序。

通常可以将Linux的中断分为异常、硬件中断、系统调用。硬件中断是异步的，也就是外部硬件随时都有可能发出中断，比如按下键盘。处理中断时，CPU会关中断，也就是不允许处理中断时，再响应其他中断，发生中断套嵌。异常和系统调用是同步的，也就是执行某一条指令导致的，比如除零异常、缺页异常；系统调用是通过执行int 0x80指令导致的，对应的中断号为128。处理异常和系统调用不会关中断，也就是CPU在执行异常处理程序或系统调用时，如果产生硬件中断，则会响应中断，执行中断处理程序。

因此如果在用户态执行系统调用，会改变特权级，需要从tss表中切换内核栈，而已经在内核态的时候执行系统调用，则不会改变特权级，不需要切换栈，其余操作一样。

### 中断返回
中断返回就是出栈的过程，将第三步保护现场压入栈中的信息弹出。

1、有错误码弹出错误码。
2、此时的栈顶指针ESP应指向EIP_old，剩余栈中的信息使用iret指令弹出，CPU执行到iret指令时再次检查和比较特权级是否变化。
3、弹出EIP_old, CS_old
4、若特权级变化，将ESP_old, SS_old, 加载到ESP，SS寄存器。
